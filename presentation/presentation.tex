\documentclass{beamer}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\usepackage[backend=bibtex]{biblatex}
\addbibresource{citations.bib}

% http://tex.stackexchange.com/questions/68080/beamer-bibliography-icon
\setbeamertemplate{bibliography item}{%
  \ifboolexpr{ test {\ifentrytype{book}} or test {\ifentrytype{mvbook}}
    or test {\ifentrytype{collection}} or test {\ifentrytype{mvcollection}}
    or test {\ifentrytype{reference}} or test {\ifentrytype{mvreference}} }
    {\setbeamertemplate{bibliography item}[book]}
    {\ifentrytype{online}
       {\setbeamertemplate{bibliography item}[online]}
       {\setbeamertemplate{bibliography item}[article]}}%
  \usebeamertemplate{bibliography item}}

\defbibenvironment{bibliography}
  {\list{}
     {\settowidth{\labelwidth}{\usebeamertemplate{bibliography item}}%
      \setlength{\leftmargin}{\labelwidth}%
      \setlength{\labelsep}{\biblabelsep}%
      \addtolength{\leftmargin}{\labelsep}%
      \setlength{\itemsep}{\bibitemsep}%
      \setlength{\parsep}{\bibparsep}}}
  {\endlist}
  {\item}

% Colours for beamer.
\setbeamercolor{frametitle}{fg=orange}
\setbeamertemplate{itemize item}{\color{orange}$\blacksquare$}
\setbeamertemplate{itemize subitem}{\color{orange}$\blacktriangleright$}

% Colours for syntax highlighting
\definecolor{syntax_red}{rgb}{0.7, 0.0, 0.0} % For strings
\definecolor{syntax_green}{rgb}{0.15, 0.5, 0.25} % For comments
\definecolor{syntax_orange}{rgb}{0.7, 0.4, 0.2} % For keywords


% Haskell settings for lstlisting
\lstset{language=Haskell,
basicstyle=\ttfamily\tiny,
keywordstyle=\color{syntax_orange}\bfseries,
stringstyle=\color{syntax_red},
commentstyle=\color{syntax_green},
numbers=none,
numberstyle=\color{black},
stepnumber=1,
frame=single,
breaklines=true,
numbersep=10pt,
tabsize=4,
showspaces=false,
showstringspaces=false}

\author{
  Beck, Calvin\\
  \href{mailto:hobbes@ualberta.ca}{hobbes@ualberta.ca}
}

\begin{document}

\begin{frame}
  \frametitle{A Journey Through Types}
  \maketitle
\end{frame}

\section{Introduction}

\begin{frame}
  \frametitle{What is this Talk about?}

  Types! This presentation hopes to address the following:

  \begin{itemize}
  \item How types can help you write correct software.
    \begin{itemize}
    \item This is important when \emph{EVERYTHING} runs software.
    \item Good type systems can make this less horrifying!
    \end{itemize}
  \item How types make things easier to write in general.
    \begin{itemize}
    \item Compiler can automate a lot more.
    \item Compiler can catch many simple issues.
    \end{itemize}
  \end{itemize}

  \pause

  Somewhat of a whirlwind introduction. Let me know if you're lost,
  because this talk is all over the place!
\end{frame}

\section{What are types, and how do they help us?}

\begin{frame}[fragile]
  \frametitle{What are we trying to solve?}

  You think that this is normal...

  \pause

  \begin{lstlisting}[frame=single, language=Python, breaklines=true]
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'NoneType' object is not subscriptable
  \end{lstlisting}

  \pause

  \huge{... It's not!}
\end{frame}

\begin{frame}
  \frametitle{What is a type?}

  A type describes what a value ``is''.

  \pause

  You have probably heard of this as ``how the bits are stored in memory.''

  \pause

  It's a bit more than that!

  \pause

  \begin{itemize}
  \item Tell us how to use values.
    \begin{itemize}
    \item Tells us what operations are defined on the types.
    \item Can you add things of this type?
    \item Can a function take a value of this type as an argument?
    \item What kind of stuff does this function return?
    \end{itemize}

  \pause

  \item Documentation

  \pause

  \item Rejection of general nonsense: \(357^\text{circles}\)

  \pause

  \begin{itemize}
  \item \huge{NO MORE NULL REFERENCE EXCEPTIONS!}
  \end{itemize}
  \end{itemize}
\end{frame}

\section{The types you may have seen}

\begin{frame}[fragile]
  \frametitle{The types you may have seen: Python}
  \begin{lstlisting}[frame=single, language=Python, breaklines=true, basicstyle=\ttfamily\tiny]
     def my_sort(xs):
         if xs == []:
             return xs
         else:
             first_elem = xs[0]
             rest = xs[1:]

             smaller = my_sort([x for x in rest if x <= first_elem])
             larger = my_sort([x for x in rest if x > first_elem])

             return smaller + [first_elem] + larger


     def my_factorial(n):
         if n == 0:
             return 1
         else:
             return n * my_factorial(n-1)
  \end{lstlisting}

  \begin{itemize}
  \item No types to help document functions.

  \item No types to catch errors at compile time.
    \begin{itemize}
    \item Tests can help...
    \item But it's nice to not have to worry about certain errors at all.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The types you may have seen: Python}

  \begin{itemize}
  \item What if we could force functions to be compartmentalized?
    \begin{itemize}
    \item No sneaky IO
    \item No hidden global states
    \end{itemize}
    
  \pause
  \item Wouldn't it be nice to have a description of what a function can and can't do in a concise format?

  \pause
  \item Could the compiler tell us when our function deviates from these descriptions?
    \begin{itemize}
    \item Why wait until runtime to find your mistakes?
    \end{itemize}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The types you may have seen: Java}

  \begin{lstlisting}[frame=single, language=Java, breaklines=true, basicstyle=\ttfamily\tiny]
     Integer factorial(Integer n) {
         if (n == 0) {
             return 1;
         }
         else {
             return n * factorial(n - 1);
         }
     }

     ArrayList<Integer> my_sort(ArrayList<Integer> xs) {
         if (xs.size() == 0) {
             return new ArrayList<Integer>();
         }
         else {
             // ...
             // Calvin is too lazy to write Java
             // ...
         }
     }
   \end{lstlisting}

   \begin{itemize}
   \pause
   \item Very verbose. Lots of additional syntactic cruft.
   \pause
   \item Can see what functions accept and return!
   \pause
   \item Null references... :c
   \end{itemize}

   \pause

   Types aren't bad... \pause Java is bad.
\end{frame}

\begin{frame}
  \frametitle{Greener pastures and better ideas}

  What do we want in our types?

  \begin{itemize}
    \pause
  \item Catch errors at compile time!
    \begin{itemize}
    \item If something is ``wrong'', then why wait for runtime to tell us?
    \end{itemize}
    \pause
  \item Ease reading and writing of programs.
    \begin{itemize}
    \item Act as a kind of documentation.
    \item Guide us when writing programs.
    \item Stop us from making mistakes.
    \end{itemize}
    \pause
  \item Allow us to make better guarantees.
    \begin{itemize}
    \item ``Function does not alter global state''
    \item ``Function does not read from disk''
    \end{itemize}
    \pause
  \item Not too much verbosity.
    \begin{itemize}
    \item Nice, clean syntax!
    \end{itemize}
  \end{itemize}   
\end{frame}

\section{Haskell}

\begin{frame}[fragile]
  \frametitle{Introducing Haskell!}
  \pause
  \begin{lstlisting}[frame=single, language=Java, breaklines=true, basicstyle=\ttfamily\tiny]
     def my_sort(xs):
         if xs == []:
             return xs
         else:
             first_elem = xs[0]
             rest = xs[1:]

             smaller = my_sort([x for x in rest if x <= first_elem])
             larger = my_sort([x for x in rest if x > first_elem])

             return smaller + [first_elem] + larger


     def my_factorial(n):
         if n == 0:
             return 1
         else:
             return n * my_factorial(n-1)
  \end{lstlisting}

  \pause

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     mySort :: Ord a => [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]


     factorial :: Integer -> Integer
     factorial 0 = 1
     factorial n = n * factorial (n - 1)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Introducing Haskell!}
    \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     mySort :: Ord a => [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]


     factorial :: Integer -> Integer
     factorial 0 = 1
     factorial n = n * factorial (n - 1)
   \end{lstlisting}

   \begin{itemize}
   \item Type inference: compiler can figure out the types of things.
   \item Nice, relatively specific types.
     \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
       -- Causes a type error, because it doesn't make sense.
       mySort [factorial, (*2)]
     \end{lstlisting}

     Something similar in Python would only be caught at runtime
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{We need \texttt{Ord}!}
  You might think you could do this:

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     -- Instead of: Ord a => [a] -> [a]
     mySort :: [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]
   \end{lstlisting}

   \pause

   ... But this actually causes a type error!

   \pause

   \begin{itemize}
   \item $a$ could be \emph{any type}
   \item This type could be unorderable
     \begin{itemize}
     \item Like a function, or a picture
     \end{itemize}
   \item Need the constraint so we know we can perform comparisons!
   \end{itemize}

   \pause

   Haskell makes sure we can only perform operations that are defined on values of a given type, but allows us to be general about it. This function works with any orderable element still, and not just a fixed type.
   
\end{frame}

\begin{frame}
  \frametitle{More care in a type}

  Haskell is somewhat careful about what values inhabit a type.

  \pause
  \begin{itemize}
  \item No ``null'' values which inhabit every type.
  \pause
  \item This keeps it so that, for the most part, elements of a type act the same way.
  \pause
  \item Operations on elements of a type work on all values, so no runtime exceptions are raised!
  \end{itemize}

  \pause

  This helps to keep everything sane!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Maybe maybe!}

  Sometimes you need something \emph{like} a null. Maybe a function can't always compute an answer! \\~\\

  \pause
  Enter maybe types: \\~\\

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
    data Maybe a = Just a | Nothing
  \end{lstlisting}

  \pause

  \begin{itemize}
  \item Better than null!
  \item Type checker can tell us when we need to handle null.
  \item Compile time errors if we don't handle null!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Maybe examples}

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     -- Find out where a value is in a list.
     whichIndex :: Eq a => a -> [a] -> Maybe Integer
     whichIndex = whichIndexAcc 0

     -- Helper function that remembers our position in the list.
     whichIndexAcc :: Eq a => Integer -> a -> [a] -> Maybe Integer
     whichIndexAcc pos value [] = Nothing
     whichIndexAcc pos value (x::xs) = if x == value
                                        then Just pos
                                        else whichIndexAcc (pos+1) xs

     -- A dictionary of all the important words.
     dictionary :: [String]
     dictionary = ["cats", "sandwiches", "hot chocolate"]

     main :: IO ()
     main = do entry <- getLine
               case whichIndex entry dictionary of
                    (Just pos) => putStrLn "Your entry is at position " ++ show pos ++ " in the dictionary."
                    Nothing => putStrLn "Your entry does not appear in the dictionary."
  \end{lstlisting}

  \begin{itemize}
  \item You know \texttt{whichIndex} can yield a ``null'' value (\texttt{Nothing}). Just from type.
  \item Could also be a \texttt{Just <Integer>}, such as \texttt{Just 3}.
  \item You have to explicitly unwrap these values (see \texttt{main}) to get at the possible value!
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Maybe more!}

  Seems tedious? It's not! Good syntax makes this easy!
  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
-- Look up a word in the same position in a different dictionary.
dictionary :: [String]
dictionary = ["cats", "sandwiches", "hot chocolate"]


synonyms :: [String]
synonyms = ["meows", "bread oreos", "sweet nectar"]


moreSynonyms :: [String]
moreSynonyms = ["floofs", "subs", "hot coco"]

-- Get value at index, Nothing if out of range.
getIndex :: Integer -> [a] -> Maybe a
getIndex _ [] = Nothing
getIndex 0 (x:xs) = Just x
getIndex n (_:xs) = getIndex (n-1) xs
  \end{lstlisting}

  More on next slide...

\end{frame}

\begin{frame}[fragile]
  ``Do'' notation frees us from tedium!

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
lookupSynonyms :: String -> Maybe (String, String)
lookupSynonyms word = do index <- getIndex word dictionary

                         -- Lookup my synonyms, if anything fails return Nothing.
                         firstSynonym <- getIndex index synonyms
                         secondSynonym <- getIndex index moreSynonyms

                         -- Success! Return Just the synonyms.
                         Just (firstSynonym, secondSynonym)

-- lookupSynonyms essentially desugars to this.
-- The compiler can help avoid this tedium!
painfulLookupSynonyms :: String -> Maybe (String, String)
painfulLookupSynonyms word = case getIndex word dictionary of
                                  Nothing -> Nothing
                                  (Just index) ->
                                    case getIndex index synonyms of 
                                         Nothing -> Nothing
                                         (Just first) ->
                                           case getIndex index moreSynonyms of
                                                Nothing -> Nothing
                                                (Just second) -> Just (first, second)

main :: IO ()
main = do word <- getLine
          case lookupSynonym word of
            Nothing -> putStrLn ("Hmmm, I don't know a synonym for " ++ word)
            (Just synonym) -> putStrLn ("I think " ++ word ++ "'s are a lot like " ++ synonym ++ "'s!")
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Last words on Maybe}
  
  If you're a JavaScript programmer you've probably encountered
  promises. In a language like Haskell you could also have a promise
  type, which is similar to \texttt{Maybe}. Imagine having:

  \begin{itemize}
  \pause
  \item The type checker tell you when you forgot to ``unwrap'' a promise.
  \pause
  \item Do notation which lets you string promises together with no syntactic overhead.
  \pause
  \item Not having to write JavaScript ;)
  \end{itemize}

  Having a good type system in an expressive language, like Haskell,
  can really help ease a lot of the pain you currently suffer.

  \pause \\~\\

  Programming can be good?
\end{frame}

\begin{frame}[fragile]
  \frametitle{IO types}

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     -- putStrLn :: IO ()
     -- getLine :: IO String

     main :: IO ()
     main = do putStrLn "What is your name?"
               name <- getLine
               putStrLn ("Hello, " ++ name)
  \end{lstlisting}

  \begin{itemize}
  \item \texttt{IO} means a function performs input / output.
    \begin{itemize}
    \pause
    \item Reads from disk, or stdin
    \pause
    \item Writes to disk, prints to screen
    \pause
    \item etc...
    \end{itemize}
  \pause
  \item \texttt{()} is ``void'' --- no return value.
  \pause
  \item No escaping \texttt{IO}. Taints anything using it, so you know if something does input / output.
  \pause
  \item Can help avoid unexpected behaviour, similar to global state changing a functions behaviour.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Haskell in summary: what does it buy us?}

  \begin{itemize}
  \item We can catch errors at compile time!
    \begin{itemize}
    \item Type system lets us describe values in a fair amount of detail, which removes a lot of obviously incorrect programs from the set of programs that compile.
    \item Types don't contain nulls. Very few values which cause explosions at runtime.
    \end{itemize}
  \item Easier to read and write programs. Types of functions are very descriptive!
    \begin{itemize}
    \item Types help in much the same way as test driven development (but they're always there, unlike tests!)
      \begin{itemize}
      \item Makes you think about arguments a function takes, and what it returns
      \end{itemize}
    \item Types point out errors when developing, such as forgetting to unwrap a Maybe value.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{What more does it buy us?}
  \begin{itemize}
  \item Types can be very general, allowing us to reuse functions with any type that makes sense.
    \begin{itemize}
    \item \texttt{mySort} works with any list of orderable elements!
    \end{itemize}
  \item It allows us to specify properties and guarantees within our programs.
    \begin{itemize}
    \item ``This function does not alter global state, or read from a file''.
    \item Functions are ``pure''.
    \item Special actions, like \texttt{IO}, are clearly labeled.
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Enter dependent types}

  There are some things that we just can't do with Haskell's types.

  \pause \\~\\

  Can write this:

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
    index :: Integer -> [a] -> Maybe a
    index 0 [] = Nothing
    index 0 (x::xs) = Just x
    index n (x::xs) = index (n-1) xs
  \end{lstlisting}

  \pause
  But can't just avoid calling an index function when the index is out of range:

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
    -- Want the integer argument to always be in range so we don't need Maybe!
    index :: Integer -> [a] -> a
    index 0 [] = error "Uh... Whoops, walking off the end of the list!"
    index 0 (x :: xs) = x
    index n (x :: xs) = index (n-1) xs
  \end{lstlisting}

  \pause \\~\\

  \begin{itemize}
  \item Need to encode length of the list into the type.
  \item Can't do this in Haskell because a type can not depend upon a value.
    \begin{itemize}
    \item Length in the type must depend upon the length of the list value.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{More motivation...}

  Also not possible to encode specific properties which depend upon values in types.

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
    mySort :: Ord a => [a] -> [a]
    mySort [] = []
    mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
      where smaller = mySort [x | x <- rest, x <= first_elem]
            larger = mySort [x | x <- rest, x > first_elem]
  \end{lstlisting}

  \pause
  Would be nice to encode into the type of \texttt{mySort} that...
  
  \begin{itemize}
  \item Output list must be in ascending order.
  \item Output list must contain the same values as the input list.
  \end{itemize}

  \pause

  This would prove that the program works! \texttt{mySort} would be
  guaranteed to sort a list in ascending order if the program type
  checks!

  \pause

  We can do this kind of thing with dependent types. We'll look at
  some basic examples in Idris, a programming language like Haskell, but
  with dependent types.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dependent types in Idris}

  Vectors are a classic example of dependent types!

  \begin{itemize}
  \pause
  \item Like lists, but...
  \pause
  \item They include the length of the list in the type.
  \end{itemize}

  \begin{lstlisting}[frame=single, language=Idris, breaklines=true, basicstyle=\ttfamily\tiny]
    two_little_piggies : Vect 2 String
    two_little_piggies = ["Oinkers", "Snorkins"]

    -- This would be a type error, caught at compilation:
    three_little_piggies : Vect 3 String
    three_little_piggies = two_little_piggies
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Append and the type level computations}

  Computations at the type level allow us to make some more complicated, generalized functions.

  \pause

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
  \end{lstlisting}

  \pause

  \texttt{n}, \texttt{m}, and \texttt{(n + m)} are all natural numbers, and \texttt{elem} is any type.

  \pause

  \begin{lstlisting}[language=Idris]
    data Vect : Nat -> Type -> Type where
      Nil : Vect 0 a
      (::) : (x : a) -> Vect k a -> Vect (S k) a
  \end{lstlisting}

  \begin{itemize}
  \pause
  \item The full \texttt{Vect} type constructed from natural number value for length, and a type for the elements.
  \pause
  \item Two constructors define the type recursively (called an inductive type -- we'll see why later).
    \begin{itemize}
    \item One for the empty vector.
    \item Single value concatenated to another vector to make a vector with 1 more element. \texttt{S} is successor of natural numbers, +1.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Types and automation}

  Idris can help us generate programs based on the types. (All the steps you will see are done automatically by Idris).

  \pause \\~\\

  We can ask idris to start our function definition based on the type:

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append xs ys = ?append_rhs
  \end{lstlisting}

  \pause
  \texttt{?append\_rhs} is a hole. It's a stand in for a value we need
  to provide. Idris can tell us the type of a hole, and potentially fill
  it in for us. It also tells us types of what's in scope for the hole. This looks like this:

  \pause \\~\\

  \begin{lstlisting}[language=Idris]
- + Main.append_rhs [P]
 `__             elem : Type
                    m : Nat
                   ys : Vect m elem
                    n : Nat
                   xs : Vect n elem
     ----------------------------------------
      Main.append_rhs : Vect (n + m) elem
  \end{lstlisting}

  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Types and automation}

  We can get Idris to do case split on the first argument...

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append xs ys = ?append_rhs      
  \end{lstlisting}

  \pause
  
  Which leads to a pattern match on constructors, and two holes:

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append [] ys = ?append_rhs_1
    append (x :: xs) ys = ?append_rhs_2
  \end{lstlisting}

  \pause

  \begin{lstlisting}[language=Idris]
- + Main.append_rhs_1 [P]
 `__               elem : Type
                      m : Nat
                     ys : Vect m elem
     ------------------------------------------
      Main.append_rhs_1 : Vect (0 + m) elem

- + Main.append_rhs_2 [P]
 `__               elem : Type
                      x : elem
                      m : Nat
                     ys : Vect m elem
                    len : Nat
                     xs : Vect k elem
     ------------------------------------------------
      Main.append_rhs_2 : Vect ((S k) + m) elem
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Types and automation}

  Once broken into cases, Idris can search for values which satisfy the types of the holes. Let's look at the first one...

  \pause

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append [] ys = ?append_rhs_1
  \end{lstlisting}

  \begin{lstlisting}[language=Idris]
- + Main.append_rhs_1 [P]
 `__               elem : Type
                      m : Nat
                     ys : Vect m elem
     ------------------------------------------
      Main.append_rhs_1 : Vect (0 + m) elem
  \end{lstlisting}

  \pause
  
  Idris actually evaluates the type \texttt{Vect (0 + m) elem}, so this is really...

  \pause

  \begin{lstlisting}[language=Idris]
- + Main.append_rhs_1 [P]
 `__               elem : Type
                      m : Nat
                     ys : Vect m elem
     ------------------------------------------
      Main.append_rhs_1 : Vect m elem
  \end{lstlisting}

  \pause

  Only \texttt{ys} satisfies this type. Remember \texttt{m} could be any natural.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Types and automation}
  So, Idris can tell that it can use \texttt{ys} for this case, giving us:

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append [] ys = ys
    append (x :: xs) ys = ?append_rhs_2
  \end{lstlisting}

  \pause

  The second hole is a bit more interesting:

  \begin{lstlisting}[language=Idris]
    - + Main.append_rhs_2 [P]
     `__               elem : Type
                          x : elem
                          m : Nat
                         ys : Vect m elem
                          k : Nat
                         xs : Vect k elem
         ----------------------------------------------
          Main.append_rhs_2 : Vect ((S k) + m) elem
  \end{lstlisting}

  \pause

  ... Idris can also fill this in.

  \pause

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append [] ys = ys
    append (x :: xs) ys = x :: append xs ys
  \end{lstlisting}

  \pause

  This seems bonkers, so let's look at how Idris did this.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Idris the smart and brave}

  To get \lstinline[language=Idris, columns=fixed]{append (x :: xs) ys = x :: append xs ys} Idris realized a couple things:

  \begin{lstlisting}[language=Idris]
    data Nat : Type where
      0 : Nat -- Zero
      S : Nat -> Nat -- Successor (+1)


    (+) : Nat -> Nat -> Nat
    (+) 0 m = m
    (+) (S k) m = S (k + m)
  \end{lstlisting}

  \pause
  Remember our hole:

  \begin{lstlisting}[language=Idris]
    Main.append_rhs_2 : Vect (( S k ) + m ) elem
  \end{lstlisting}

  \pause
  By definition \lstinline[language=Idris, columns=fixed]{(S k) + m = S (k + m)}, so we have:

  \pause
  \begin{lstlisting}[language=Idris]
    Main.append_rhs_2 : Vect (S (k + m)) elem
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Idris the smart and brave}

  So we really have this goal:

  \begin{lstlisting}[language=Idris]
    Main.append_rhs_2 : Vect (S (k + m)) elem
  \end{lstlisting}

  Idris looks at how to construct a \lstinline[language=Idris,columns=fixed]{Vect (S blah) elem}...

  \pause

  \begin{lstlisting}[language=Idris]
    data Vect : Nat -> Type -> Type where
      Nil : Vect 0 a
      (::) : (x : a) -> Vect k a -> Vect (S k) a
  \end{lstlisting}

  \pause
  To construct a \lstinline[language=Idris,columns=fixed]{Vect (S blah) elem} we need \texttt{::}!

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append [] ys = ys
    append (x :: xs) ys = ?elem_to_concat :: ?rest_of_vect
  \end{lstlisting}

  \pause
  These are the holes:

  \begin{lstlisting}[language=Idris]
    Main.elem_to_concat : elem

    Main.rest_of_vect : Vect (k + m) elem
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Idris the smart and brave}  
  The first hole is easy for Idris.

  \begin{lstlisting}[language=Idris]
    - + Main.elem_to_concat [P]
     `__                 elem : Type
                            x : elem
                            m : Nat
                           ys : Vect m elem
                            k : Nat
                           xs : Vect k elem
         -----------------------------------
          Main.elem_to_concat : elem
  \end{lstlisting}

  \pause
  We need something with the arbitrary type \texttt{elem}. Only \texttt{x} fits!

  \pause

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append [] ys = ys
    append (x :: xs) ys = x :: ?rest_of_vect
  \end{lstlisting}

  \pause

  Second hole involves a bit more work...
\end{frame}

\begin{frame}[fragile]
  \frametitle{Daily dose of recursion}

  \begin{lstlisting}[language=Idris]
    - + Main.rest_of_vect [P]
     `__               elem : Type
                          x : elem
                          m : Nat
                         ys : Vect m elem
                          k : Nat
                         xs : Vect k elem
         ------------------------------------------
          Main.rest_of_vect : Vect (k + m) elem
  \end{lstlisting}

  \pause
  Idris knows it can call \texttt{append} recursively with a
\lstinline[language=Idris,columns=fixed]{Vect k elem} and a
\lstinline[language=Idris,columns=fixed]{Vect m elem} to get a
\lstinline[language=Idris,columns=fixed]{Vect (k + m) elem}.

  \pause \\~\\

  Looking at our goal we have such vectors, \texttt{ys} and \texttt{xs}.

  \pause
  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append [] ys = ys
    append (x :: xs) ys = x :: append xs ys
  \end{lstlisting}

  \pause
  Idris wrote this function automatically based on a small spec!

  \pause
  It's cool that Idris even gets the order correct because of the types!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Less precise types}

  Doesn't work well with the less precise list type!

  \pause
  \begin{lstlisting}[language=Idris]
    append : List elem -> List elem -> List elem
    append [] ys = ?append_rhs1
    append (x :: xs) ys = ?append_rhs2
  \end{lstlisting}

  What do you think will happen when we try the same thing?

  \pause
  \begin{lstlisting}[language=Idris]
    append : List elem -> List elem -> List elem
    append [] ys = []
    append (x :: xs) ys = []
  \end{lstlisting}

  Huh... I guess it doesn't realize that append should make a list as long as the inputs combined!

  \\~\\
  Idris just finds the first possible function. Length isn't encoded in the type to enforce length of output.
\end{frame}

\begin{frame}[fragile]
  \frametitle{A careful index}

  In Haskell we couldn't guarantee that an index was in range of a list... \pause In Idris we can!

  \pause
  \begin{lstlisting}[language=Idris]
     index : Fin len -> Vect len elem -> elem
     index FZ (x :: xs) = x
     index (FS n) (_ :: xs) = myIndex n xs 
   \end{lstlisting}

   \texttt{Fin len} is a type for natural numbers strictly less than \texttt{len}

   \pause

   \begin{lstlisting}[language=Idris]
     data Fin : Nat -> Type where
       FZ : Fin (S k)
       FS : Fin k -> Fin (S k)
     \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A tale of cautious indexing}

  \begin{lstlisting}[language=Idris]
    cats : Vect 2 String
    cats = ["The Panther", "Smoke Smoke"]

    -- "The Panther" : String
    index 0 cats -- This type checks.


    -- (input):1:9:When checking argument prf to function Data.Fin.fromInteger:
    --         When using 2 as a literal for a Fin 2 
    --                 2 is not strictly less than 2
    index 2 cats -- This is out of bounds, so the program won't even compile!
  \end{lstlisting}

  \pause \\~\\

  \huge{Lots of cool guarantees that we can make with dependent types!}
\end{frame}

\begin{frame}
  \frametitle{Logic primer}

  What are propositions?

  \begin{itemize}
  \pause
  \item A statement: ``the sky is blue'', ``2 + 2 is 4''
  \pause
  \item Not necessarily true: ``2 + 2 is 27''
  \end{itemize}

  \pause

  Logical proofs are used to determine the validity of a proposition.

  \pause \\~\\

  We could show that ``2 + 2 is 27'' is false with a logical proof.
\end{frame}

\begin{frame}
  \frametitle{Variables}

  Propositions are often represented by variables, for instance:

  \[
    p
  \]

  \pause
  $p$ is a proposition. It could be anything, really...

  \pause
  \[
    p = ``\text{ducks are fantastic}''
  \]

  \pause
  And I might have another proposition:

  \[
    q = ``\text{ducks are truly the worst}''
  \]

  \pause
  We can build up more complicated propositions with logical connectives. In this case we might have:

  \[
    p \rightarrow \neg q
  \]

  Which means that if $p$ is true, then $q$ is not true. We'll see more of this shortly.
\end{frame}

\begin{frame}
  \frametitle{More logic}

  We've mostly been using plain English to convey these propositions, but often they'll be more mathematical statements, such as:

  \[\forall n \in \mathrm{N}, \exists m \in \mathrm{N} \text{ such that } m > n\]

  \pause \\~\\

  Propositions...

  \begin{itemize}
  \item Are built up from a set of axioms
    \begin{itemize}
    \item Just rules which describe your mathematical objects
    \end{itemize}
  \pause
  \item Can be combined with logical connectives.
  \end{itemize}

  \pause \\~\\

  Logic is a sort of metalanguage which describes how you can make judgements about your mathematical objects.
\end{frame}

\begin{frame}
  \frametitle{Logical connectives}

  In a logical system you might have these logical connectives:

  \begin{itemize}
  \pause
  \item Implication:
    \begin{itemize}
    \item $p \rightarrow q$, meaning ``if $p$ is true, then $q$ must be true.''
    \end{itemize}
  \pause
  \item Conjunction:
    \begin{itemize}
    \item $p \wedge q$, meaning ``both $p$ and $q$ are true.''
    \end{itemize}
  \pause
  \item Disjunction:
    \begin{itemize}
    \item $p \vee q$, meaning ``at least one of $p$ or $q$ is true.''
    \end{itemize}
  \pause
  \item Negation:
    \begin{itemize}
    \item $\neg p$, meaning ``not $p$'', ``$p$ is false.''
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Quantification}
  You might also have quantifiers:

  \begin{itemize}
  \pause
  \item Universal quantification:
    \begin{itemize}
    \item $\forall x \in S, p(x)$, meaning ``for every $x$ (in $S$), $p(x)$ is true.''
    \end{itemize}
  \pause
  \item Existential quantification:
    \begin{itemize}
    \item $\exists x \in S, p(x)$, meaning ``there's at least on $x$ (in $S$), which makes $p(x)$ true.''
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Proof and inference rules}

  You also have some rules for how you can combine these things to form proofs. E.g., Modus ponens

  \[p \rightarrow q, p \vdash q\]

  \pause

  Or conjunction elimination

  \[p \wedge q \vdash p\]

  \[p \wedge q \vdash q\]

  \pause

  Or conjunction introduction

  \[p, q \vdash p \wedge q\]
\end{frame}

\begin{frame}[fragile]
  \frametitle{Curry-Howard Isomorphism: Propositions as Types!}

  Things get interesting when you start thinking about types as propositions...

  \pause

  \[p \rightarrow q\]

  \pause
  This looks an awful lot like...

  \begin{lstlisting}[language=Idris]
    hmmm1 : p -> q
  \end{lstlisting}

  \pause \\~\\
  Similarly...

  \[p \wedge q\]

  \pause
  Is kind of similar to:

  \begin{lstlisting}[language=Idris]
    hmmm2 : (p, q)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Curry-Howard Isomorphism: Propositions as Types!}

  Conjunction elimination corresponds to destructing a product...
  \begin{lstlisting}[language=Idris]
    -- P /\ Q -> P
    fst : (p, q) -> p
    fst (a, b) = a

    -- P /\ Q -> Q
    snd : (p, q) -> q
    snd (a, b) = b
  \end{lstlisting}

  \pause
  Conjuction introduction corresponds to constructing a product...
  \begin{lstlisting}[language=Idris]
    -- P -> Q -> (P, Q)
    and : p -> q -> (p, q)
    and a b = (a, b)
  \end{lstlisting}

  \pause \\~\\
  Similar things for other logical connectives. E.g., $p \vee q$ corresponds to a sum type \texttt{Either p q}.

  \pause \\~\\
  $\neg p$ corresponds to \texttt{p -> Void} where \texttt{Void} is an uninhabited type.

  \pause \\~\\
  Dependent types are needed for quantifiers.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Valuable proofs}
  If types are propositions, then what are the values?

  \pause \\~\\
  Well, they're a sort of ``existence proof'' of a proposition.

  \pause
  \begin{lstlisting}[language=Idris]
    const : p -> q -> p
    const a b = a
  \end{lstlisting}

  \pause
  The value \texttt{const} can be seen as a proof of the proposition (type) \texttt{p -> q -> p}... This is what \texttt{const} says:

  \begin{itemize}
  \pause
  \item given a proof of \texttt{p}, \texttt{a}
  \pause
  \item and a proof of \texttt{q}, \texttt{b}
  \pause
  \item I can provide \texttt{a} as a proof of \texttt{p}
  \end{itemize}

  \pause \\~\\
  Which oddly enough makes a lot of sense as proof!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Invaluable proofs}

  Type checker can prevent bogus proofs! Stops us from proving false propositions!

  \pause
  \begin{lstlisting}[language=Idris]
    bogus : p -> q
    bogus p = -- What can I put here that would type check? :(
  \end{lstlisting}

  \pause
  Can't find a value of type \texttt{q}, since we only have a value of type \texttt{p}!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Proofs in practice}

  Idris has a type for equality between two things.

  \pause
  \begin{lstlisting}[language=Idris]
    equality_good : 2+3 = 5 -- Equality as a proposition in the type!
    equality_good = Refl

    -- This fails to type check
    equality_bad : 2+3 = 7
    equality_bad = Refl
  \end{lstlisting}

  \pause
  Equality has only one constructor, \texttt{Refl}. This is roughly defined as:

  \pause
  \begin{lstlisting}[language=Idris]
    data (=) : a -> b -> Type where
      Refl : x = x
  \end{lstlisting}

  \pause \\~\\

  Looks a little obtuse... But if we need a \texttt{something = blah} type, we use \texttt{Refl}.

  \pause \\~\\

  Idris will try to determine if they are equal from the definitions it knows about.

  \pause
  E.g., \texttt{2+3 = 5}, since Idris can evaluate \texttt{2+3} to \texttt{5}, and see that they are identical.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Congruency}

  \begin{lstlisting}[language=Idris]
    cong : (f : a -> b) -> x = y -> f x = f y
    cong f prf = ?cong_rhs
  \end{lstlisting}

  \pause
  Seems a bit scary! Equality in the types!

  \pause \\~\\
  Remember that this just means we need to construct a type using
  \texttt{Refl}. Idris just needs to show that the left and right hand
  side are equal.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Congruency}

  This is our goal:

  \begin{lstlisting}[language=Idris]
     - + Main.cong_rhs [P]
    `__              b : Type
                     a : Type
                     x : a
                     f : a -> b
                     y : a
                   prf : x = y
        ---------------------------
         Main.cong_rhs : f x = f y
  \end{lstlisting}

  \pause
  We can get some help by pattern matching!

  \begin{lstlisting}[language=Idris]
    cong : (f : a -> b) -> x = y -> f x = f y
    cong f Refl = ?cong_rhs_1
  \end{lstlisting}

  \pause
  Looks unimpressive, but it changed our goal:

  \begin{lstlisting}[language=Idris]
    - + Main.cong_rhs_1 [P]
     `__                b : Type
                        a : Type
                        x : a
                        f : a -> b
         -----------------------------
          Main.cong_rhs_1 : f x = f x
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Congruency}

  \texttt{Refl} lets us construct equalities.

  \begin{lstlisting}[language=Idris]
    Refl : x = x

    -- So, if we just replace the general "x" above with our "f x" we
    -- would get...
    Refl : f x = f x
  \end{lstlisting}

  \pause
  \texttt{Refl} uses implicit arguments, can infer from context:

  \begin{lstlisting}[language=Idris]
    cong : (f : a -> b) -> x = y -> f x = f y
    cong f Refl = Refl
  \end{lstlisting}

  \pause
  Can also provide the argument explicitly:

  \begin{lstlisting}[language=Idris]
    cong : (f : a -> b) -> x = y -> f x = f y
    cong f (Refl {x}) = Refl {x = f x}
  \end{lstlisting}

  \pause
  Bit confusing because \texttt{x} is in both places, but \texttt{x}
  in the definition of \texttt{Refl} is in a different scope, and we
  substitute \texttt{f x} for \texttt{x}.

  \pause \\~\\

  This concludes the proof of \texttt{cong}!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Slightly more complicated proofs}

  Let's prove the associativity of addition on natural numbers!

  \pause \\~\\

  Here's our nice unary representation of natural numbers:

  \begin{lstlisting}[language=Idris]
     data Nat : Type where
       0 : Nat
       S : Nat -> Nat -- Successor, +1

     -- 0 = 0
     -- S 0 = 1
     -- S (S 0) = 2
     -- etc...
   \end{lstlisting}
   
   \pause \\~\\

   Addition looks like this:

   \begin{lstlisting}[language=Idris]
     (+) : Nat -> Nat -> Nat
     (+) 0 y = y
     (+) (S x) y = S (x + y)
   \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Associativity}

  \begin{lstlisting}[language=Idris]
     plus_assoc : (x, y, z : Nat) -> x + (y + z) = (x + y) + z
     plus_assoc x y z = ?plus_assoc_rhs
  \end{lstlisting}

  \pause
  Case split on \texttt{x}...
  
  \begin{lstlisting}[language=Idris]
    plus_assoc : (x, y, z : Nat) -> x + (y + z) = (x + y) + z
    plus_assoc 0 y z = ?plus_assoc_rhs_1
    plus_assoc (S k) y z = ?plus_assoc_rhs_2
  \end{lstlisting}

  \pause
  Gives us some interesting holes...

  \begin{lstlisting}[language=Idris]
     - + Main.plus_assoc_rhs_1 [P]
      `__                      y : Nat
                               z : Nat
          ---------------------------------------------------------------
           Main.plus_assoc_rhs_1 : 0 + (y + z) = (0 + y) + z

     - + Main.plus_assoc_rhs_2 [P]
      `__                      k : Nat
                               y : Nat
                               z : Nat
          -----------------------------------------------------------------------
           Main.plus_assoc_rhs_2 : (S k) + (y + z) = ((S k) + y) + z
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{First case...}

  We have:

  \begin{lstlisting}[language=Idris]
     - + Main.plus_assoc_rhs_1 [P]
      `__                      y : Nat
                               z : Nat
          ---------------------------------------------------------------
           Main.plus_assoc_rhs_1 : 0 + (y + z) = (0 + y) + z
  \end{lstlisting}

  \pause
  Idris will evaluate expressions in an equality type when we use
  \texttt{Refl}, so this hole is really more like:

  \begin{lstlisting}[language=Idris]
     - + Main.plus_assoc_rhs_1 [P]
      `__                      y : Nat
                               z : Nat
          ---------------------------------------------------------------
           Main.plus_assoc_rhs_1 : y + z = y + z
  \end{lstlisting}

  \pause
  Which is just satisfied with reflexivity...

  \begin{lstlisting}[language=Idris]
     plus_assoc : (x, y, z : Nat) -> x + (y + z) = (x + y) + z
     plus_assoc Z y z = Refl
     plus_assoc (S k) y z = ?plus_assoc_rhs_2
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Second case...}

  Here's our goal:

  \begin{lstlisting}[language=Idris]
     - + Main.plus_assoc_rhs_2 [P]
      `__                      k : Nat
                               y : Nat
                               z : Nat
          ------------------------------------------------------------
           Main.plus_assoc_rhs_2 : (S k) + (y + z) = ((S k) + y) + z
  \end{lstlisting}

  \pause
  Idris can evaluate this some to simplify as well.

  \begin{lstlisting}[language=Idris]
     - + Main.plus_assoc_rhs_2 [P]
      `__                      k : Nat
                               y : Nat
                               z : Nat
          ------------------------------------------------------------
           Main.plus_assoc_rhs_2 : S (k + (y + z)) = S ((k + y) + z)
  \end{lstlisting}

  It looks like we need to prove associativity again...

  \pause
  \begin{lstlisting}[language=Idris]
    k + (y + z) = (k + y) + z
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion is induction!}

  Idris knows about recursion, so we can actually call
  \texttt{plus\_assoc} on \texttt{k}, \texttt{y}, and \texttt{z} to get
  something with type...

  \begin{lstlisting}[language=Idris]
    attempt : (k y z : Nat) -> k + (y + z) = (k + y) + z
    attempt k y z = plus_assoc k y z
  \end{lstlisting}

  \pause \\~\\

  So, now we just need to add \texttt{S} to both sides of this... Hmmm...

  \begin{lstlisting}[language=Idris]
     - + Main.plus_assoc_rhs_2 [P]
      `__                      k : Nat
                               y : Nat
                               z : Nat
          ------------------------------------------------------------
           Main.plus_assoc_rhs_2 : S (k + (y + z)) = S ((k + y) + z)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Enter cong}

  This is what we use \texttt{cong} for, if you remember...

  \begin{lstlisting}[language=Idris]
     cong : (f : a -> b) -> x = y -> f x = f y
     cong f (Refl {x}) = Refl {x = f x}
   \end{lstlisting}

   \pause
   If we give \texttt{cong} a function, and an equality type, it will apply the function to both sides!

   \pause
   \begin{lstlisting}[language=Idris]
     plus_assoc : (x, y, z : Nat) -> x + (y + z) = (x + y) + z
     plus_assoc Z y z = Refl
     plus_assoc (S k) y z = cong S (plus_assoc k y z)
   \end{lstlisting}

   \pause \\~\\
   This completes the proof!

   \pause

   Neat how applying a theorem is just applying a function. Also neat
   how recursion and induction are really just the same thing.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tactics}

  Can use a different meta-language like Coq's tactics to aid proofs...

  \pause
  \begin{lstlisting}[language=Coq]
    Inductive nat : Type :=
      | O : nat
      | S : nat -> nat.


    Fixpoint plus (n m : nat) : nat :=
      match n with
        | O => m
        | S n' => S (plus n' m)
      end.


    Theorem plus_assoc : forall (x y z : nat), plus x (plus y z) = plus (plus x y) z.
    Proof.
      intros x y z. induction x as [| k].
      - reflexivity.
      - simpl. (* Simplify with evaluation *)
        rewrite IHk. (* Use induction hypothesis to rewrite terms *)
        reflexivity.
    Qed.
  \end{lstlisting}

  \pause

  Can allow for very succinct and easy proof development, since meta-language can perform large automated steps!
\end{frame}

\begin{frame}
  \frametitle{Conclusion! Questions?}

  \huge{Whirlwind introduction, so you probably have many!}
\end{frame}

\begin{frame}
  \frametitle{References}

  \nocite{*}
  \printbibliography

  These are all good resources! You should look at them!
\end{frame}
\end{document}
