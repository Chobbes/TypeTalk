\documentclass{beamer}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

% Colours for beamer.
\setbeamercolor{frametitle}{fg=orange}
\setbeamertemplate{itemize item}{\color{orange}$\blacksquare$}
\setbeamertemplate{itemize subitem}{\color{orange}$\blacktriangleright$}

% Colours for syntax highlighting
\definecolor{syntax_red}{rgb}{0.7, 0.0, 0.0} % For strings
\definecolor{syntax_green}{rgb}{0.15, 0.5, 0.25} % For comments
\definecolor{syntax_orange}{rgb}{0.7, 0.4, 0.2} % For keywords


% Haskell settings for lstlisting
\lstset{language=Haskell,
basicstyle=\ttfamily\tiny,
keywordstyle=\color{syntax_orange}\bfseries,
stringstyle=\color{syntax_red},
commentstyle=\color{syntax_green},
numbers=none,
numberstyle=\color{black},
stepnumber=1,
frame=single,
breaklines=true,
numbersep=10pt,
tabsize=4,
showspaces=false,
showstringspaces=false}

\author{
  Beck, Calvin\\
  \href{mailto:hobbes@ualberta.ca}{hobbes@ualberta.ca}
}

\begin{document}

\begin{frame}
  \frametitle{A Journey Through Types}
  \maketitle
\end{frame}

\section{Introduction}

\begin{frame}
  \frametitle{What is this Talk about?}

  Types! This presentation hopes to address the following:

  \begin{itemize}
  \item How types make things easier to write.
  \item How types can help you write correct software.
  \end{itemize}

  \pause

  Somewhat of a whirlwind introduction. Let me know if you're lost,
  because this talk is all over the place!
\end{frame}

\section{What are types, and how do they help us?}

\begin{frame}[fragile]
  \frametitle{What are we trying to solve?}

  You think that this is normal...

  \pause

  \begin{lstlisting}[frame=single, language=Python, breaklines=true]
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'NoneType' object is not subscriptable
  \end{lstlisting}

  \pause

  \huge{... It's not!}
\end{frame}

\begin{frame}
  \frametitle{What is a type?}

  A type describes what a value ``is''.

  \pause

  You have probably heard of this as ``how the bits are stored in memory.''

  \pause

  It's a bit more than that!

  \pause

  \begin{itemize}
  \item Tell us how to use values.
    \pause

    \begin{itemize}
    \item Tells us what operations are defined on the types.
    \item Can you add things of this type?
    \item Can a function take a value of this type as an argument?
    \item What kind of stuff does this function return?
    \end{itemize}

  \pause

  \item Documentation

  \pause

  \item Rejection of general nonsense: \(357^\text{circles}\)

  \pause

  \begin{itemize}
  \item \huge{NO MORE NULL REFERENCE EXCEPTIONS!}
  \end{itemize}
  \end{itemize}
\end{frame}

\section{The types you may have seen}

\begin{frame}[fragile]
  \frametitle{The types you may have seen: Python}
  \begin{lstlisting}[frame=single, language=Python, breaklines=true, basicstyle=\ttfamily\tiny]
     def my_sort(xs):
         if xs == []:
             return xs
         else:
             first_elem = xs[0]
             rest = xs[1:]

             smaller = my_sort([x for x in rest if x <= first_elem])
             larger = my_sort([x for x in rest if x > first_elem])

             return smaller + [first_elem] + larger


     def my_factorial(n):
         if n == 0:
             return 1
         else:
             return n * my_factorial(n-1)
  \end{lstlisting}

  \pause
  \begin{itemize}
  \item No types to help document functions.

  \pause
  \item No types to catch errors at compile time.
    \begin{itemize}
    \pause
    \item Tests can help...
    \pause
    \item But it's nice to not have to worry about certain errors at all.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The types you may have seen: Python}

  \begin{itemize}
  \item What if we could force functions to be compartmentalized?
    \begin{itemize}
    \item No sneaky IO
    \item No hidden global states
    \end{itemize}
    
  \pause
  \item Wouldn't it be nice to have a description of what a function can and can't do in a concise format?

  \pause
  \item Could the compiler tell us when our function deviates from these descriptions?
    \begin{itemize}
    \item Why wait until runtime to find your mistakes?
    \end{itemize}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The types you may have seen: Java}

  \begin{lstlisting}[frame=single, language=Java, breaklines=true, basicstyle=\ttfamily\tiny]
     Integer factorial(Integer n) {
         if (n == 0) {
             return 1;
         }
         else {
             return n * factorial(n - 1);
         }
     }

     ArrayList<Integer> my_sort(ArrayList<Integer> xs) {
         if (xs.size() == 0) {
             return new ArrayList<Integer>();
         }
         else {
             // ...
             // Calvin is too lazy to write Java
             // ...
         }
     }
   \end{lstlisting}

   \begin{itemize}
   \pause
   \item Can see what functions accept and return!
   \pause
   \item Null references... :c
   \pause
   \item Very verbose. Lots of additional syntactic cruft.
   \end{itemize}

   \pause

   Types aren't bad... \pause Java is bad.
\end{frame}

\begin{frame}
  \frametitle{Greener pastures and better ideas}

  What do we want in our types?

  \begin{itemize}
    \pause
  \item Catch errors at compile time!
    \begin{itemize}
    \item If something is ``wrong'', then why wait for runtime to tell us?
    \end{itemize}
    \pause
  \item Ease reading and writing of programs.
    \begin{itemize}
    \item Act as a kind of documentation.
    \item Guide us when writing programs.
    \item Stop us from making mistakes.
    \end{itemize}
    \pause
  \item Not too much verbosity.
    \begin{itemize}
    \item Nice, clean syntax!
    \end{itemize}
  \end{itemize}   
\end{frame}

\section{Haskell}

\begin{frame}[fragile]
  \frametitle{Introducing Haskell!}
  \begin{lstlisting}[frame=single, language=Java, breaklines=true, basicstyle=\ttfamily\tiny]
     def my_sort(xs):
         if xs == []:
             return xs
         else:
             first_elem = xs[0]
             rest = xs[1:]

             smaller = my_sort([x for x in rest if x <= first_elem])
             larger = my_sort([x for x in rest if x > first_elem])

             return smaller + [first_elem] + larger


     def my_factorial(n):
         if n == 0:
             return 1
         else:
             return n * my_factorial(n-1)
  \end{lstlisting}

  \pause

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     mySort :: Ord a => [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]


     factorial :: Integer -> Integer
     factorial 0 = 1
     factorial n = n * factorial (n - 1)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Introducing Haskell!}
    \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     mySort :: Ord a => [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]


     factorial :: Integer -> Integer
     factorial 0 = 1
     factorial n = n * factorial (n - 1)
   \end{lstlisting}

   \begin{itemize}
   \item Type inference: compiler can figure out the types of things.
   \item Nice, relatively specific types.
     \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
       -- Causes a type error, because it doesn't make sense.
       mySort [factorial, (*2)]
     \end{lstlisting}

     Something similar in Python would only be caught at runtime
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{We need \texttt{Ord}!}
  You might think you could do this:

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     -- Instead of: Ord a => [a] -> [a]
     mySort :: [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]
   \end{lstlisting}

   \pause

   ... But this actually causes a type error!

   \pause

   \begin{itemize}
   \item $a$ could be \emph{any type}
   \item This type could be unorderable
     \begin{itemize}
     \item Like a function, or a picture
     \end{itemize}
   \item Need the constraint so we know we can perform comparisons!
   \end{itemize}

   \pause

   Haskell makes sure we can only perform operations that are defined on values of a given type, but allows us to be general about it. This function works with any orderable element still, and not just a fixed type.
   
\end{frame}

\begin{frame}
  \frametitle{More care in a type}

  Haskell is somewhat careful about what values inhabit a type.

  \pause
  \begin{itemize}
  \item No ``null'' values which inhabit every type.
  \pause
  \item This keeps it so that, for the most part, elements of a type act the same way.
  \pause
  \item Operations on elements of a type work on all values, so no runtime exceptions are raised!
  \end{itemize}

  \pause

  This helps to keep everything sane!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Maybe maybe!}

  Sometimes you need something \emph{like} a null. Maybe a function can't always compute an answer! \\~\\

  \pause
  Enter maybe types: \\~\\

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
    data Maybe a = Just a | Nothing
  \end{lstlisting}

  \pause

  \begin{itemize}
  \item Not just null!
  \pause
  \item Type checker can tell us when we need to handle null.
  \pause
  \item Compile time errors if we don't handle null!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Maybe examples}

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     -- Find out where a value is in a function.
     getIndex :: Eq a => a -> [a] -> Maybe Integer
     getIndex = getIndexAcc 0

     -- Helper function that remembers our position in the list.
     getIndexAcc :: Eq a => Integer -> a -> [a] -> Maybe Integer
     getIndexAcc pos value [] = Nothing
     getIndexAcc pos value (x::xs) = if x == value
                                        then Just pos
                                        else getIndexAcc (pos+1) xs

     -- A dictionary of all the important words.
     dictionary :: [String]
     dictionary = ["cats", "sandwiches", "hot chocolate"]

     main :: IO ()
     main = do entry <- getLine
               case getIndex entry dictionary of
                    (Just pos) => putStrLn "Your entry is at position " ++ show pos ++ " in the dictionary."
                    Nothing => putStrLn "Your entry does not appear in the dictionary."
  \end{lstlisting}

  \begin{itemize}
  \pause
  \item You know \texttt{getIndex} can yield a ``null'' value (\textt{Nothing}). Just from type.
  \pause
  \item Could also be a \texttt{Just <Integer>}, such as \texttt{Just 3}.
  \pause
  \item You have to explicitly unwrap these values (see \textt{main}) to get at the possible value!
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Maybe more!}

  Seems tedious? It's not! Good syntax makes this easy!
  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
-- Look up a word in the same position in a different dictionary.
dictionary :: [String]
dictionary = ["cats", "sandwiches", "hot chocolate"]


synonyms :: [String]
synonyms = ["meows", "bread oreos", "sweet nectar"]


moreSynonyms :: [String]
moreSynonyms = ["floofs", "subs", "hot coco"]


getIndex :: Integer -> [a] -> Maybe a
getIndex _ [] = Nothing
getIndex 0 (x:xs) = Just x
getIndex n (_:xs) = getIndex (n-1) xs
  \end{lstlisting}

  More on next slide...

\end{frame}

\begin{frame}[fragile]
  Seems tedious? It's not! Good syntax makes this easy!

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
lookupSynonyms :: String -> Maybe (String, String)
lookupSynonyms word = do index <- getIndex word dictionary

                         -- Lookup my synonyms, if anything fails return Nothing.
                         firstSynonym <- getIndex index synonyms
                         secondSynonym <- getIndex index moreSynonyms

                         -- Success! Return Just the synonyms.
                         Just (firstSynonym, secondSynonym)

-- lookupSynonyms essentially desugars to this.
-- The compiler can help avoid this tedium!
painfulLookupSynonyms :: String -> Maybe (String, String)
painfulLookupSynonyms word = case getIndex word dictionary of
                                  Nothing -> Nothing
                                  (Just index) ->
                                    case getIndex index synonyms of 
                                         Nothing -> Nothing
                                         (Just first) ->
                                           case getIndex index moreSynonyms of
                                                Nothing -> Nothing
                                                (Just second) -> Just (first, second)

main :: IO ()
main = do word <- getLine
          case lookupSynonym word of
            Nothing -> putStrLn ("Hmmm, I don't know a synonym for " ++ word)
            (Just synonym) -> putStrLn ("I think " ++ word ++ "'s are a lot like " ++ synonym ++ "'s!")
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Last words on Maybe}
  
  If you're a JavaScript programmer you've probably encountered
  promises. In a language like Haskell you could also have a promise
  type, which is similar to \texttt{Maybe}. Imagine having:

  \begin{itemize}
  \pause
  \item The type checker tell you when you forgot to ``unwrap'' a promise.
  \pause
  \item Do notation which lets you string promises together with no syntactic overhead.
  \pause
  \item Not having to write JavaScript ;)
  \end{itemize}

  Having a good type system in an expressive language, like Haskell,
  can really help ease a lot of the pain you currently suffer.

  \pause \\~\\

  Programming can be good?
\end{frame}

\begin{frame}[fragile]
  \frametitle{IO types}

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     -- putStrLn :: IO ()
     -- getLine :: IO String

     main :: IO ()
     main = do putStrLn "What is your name?"
               name <- getLine
               putStrLn ("Hello, " ++ name)
  \end{lstlisting}

  \begin{itemize}
  \pause
  \item \texttt{()} is ``void'' --- no return value.
  \pause
  \item \texttt{IO} means a function performs input / output.
    \begin{itemize}
    \pause
    \item Reads from disk, or stdin
    \pause
    \item Writes to disk, prints to screen
    \pause
    \item etc...
    \end{itemize}
  \item No escaping \texttt{IO}. Taints anything using it, so you know if something does input / output.
  \pause
  \item Can help avoid unexpected behaviour, similar to global state changing a functions behaviour.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Haskell in summary: what does it buy us?}

  \begin{itemize}
  \item We can catch errors at compile time!
    \begin{itemize}
    \item Type system lets us describe values in a fair amount of detail, which removes a lot of obviously incorrect programs from the set of programs that compile.
    \item Types don't contain nulls. Very few values which cause explosions at runtime.
    \end{itemize}
  \item Easier to read and write programs. Types of functions are very descriptive!
    \begin{itemize}
    \item Types help in much the same way as test driven development (but they're always there, unlike tests!)
      \begin{itemize}
      \item Makes you think about arguments a function takes, and what it returns
      \end{itemize}
    \item Types point out errors when developing, such as forgetting to unwrap a Maybe value.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{What more does it buy us?}
  \begin{itemize}
  \item Types can be very general, allowing us to reuse functions with any type that makes sense.
    \begin{itemize}
    \item \texttt{mySort} works with any list of orderable elements!
    \end{itemize}
  \item It allows us to specify properties and guarantees within our programs.
    \begin{itemize}
    \item ``This function does not alter global state, or read from a file''.
    \item Functions are ``pure''.
    \item Special actions, like \textt{IO}, are clearly labeled.
    \end{itemize} 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Enter dependent types}

  There are some things that we just can't do with Haskell's types.

  \pause \\~\\

  Can write this:

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
    index :: Integer -> [a] -> Maybe a
    index 0 [] = Nothing
    index 0 (x::xs) = Just x
    index n (x::xs) = index (n-1) xs
  \end{lstlisting}

  \pause
  But can't just avoid calling an index function when the index is out of range:

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
    -- Want the integer argument to always be in range so we don't need Maybe!
    index :: Integer -> [a] -> a
    index 0 [] = error "Uh... Whoops, walking off the end of the list!"
    index 0 (x :: xs) = x
    index n (x :: xs) = index (n-1) xs
  \end{lstlisting}

  \pause \\~\\

  \begin{itemize}
  \item Need to encode length of the list into the type.
  \item Can't do this in Haskell because a type can not depend upon a value.
    \begin{itemize}
    \item Length in the type must depend upon the length of the list value.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{More motivation...}

  Also not possible to encode specific properties which depend upon values in types.

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
    mySort :: Ord a => [a] -> [a]
    mySort [] = []
    mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
      where smaller = mySort [x | x <- rest, x <= first_elem]
            larger = mySort [x | x <- rest, x > first_elem]
  \end{lstlisting}

  \pause
  Would be nice to encode into the type of \texttt{mySort} that...
  
  \begin{itemize}
  \pause
  \item Output list must be in ascending order.
  \pause
  \item Output list must contain the same values as the input list.
  \end{itemize}

  \pause

  This would prove that the program works! \texttt{mySort} would be
  guaranteed to sort a list in ascending order if the program type
  checks!

  \pause

  We can do this kind of thing with dependent types. We'll look at
  some basic examples in Idris, a programming language like Haskell, but
  with dependent types.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dependent types in Idris}

  Vectors are a classic example of dependent types!

  \begin{itemize}
  \pause
  \item Like lists, but...
  \pause
  \item They include the length of the list in the type.
  \end{itemize}

  \begin{lstlisting}[frame=single, language=Idris, breaklines=true, basicstyle=\ttfamily\tiny]
    two_little_piggies : Vect 2 String
    two_little_piggies = ["Oinkers", "Snorkins"]

    -- This would be a type error, caught at compilation:
    three_little_piggies : Vect 3 String
    three_little_piggies = two_little_piggies
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Append and the type level computations}

  Computations at the type level allow us to make some more complicated, generalized functions.

  \pause

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
  \end{lstlisting}

  \pause

  \texttt{n}, \texttt{m}, and \texttt{(n + m)} are all natural numbers, and \texttt{elem} is any type.

  \pause

  \begin{lstlisting}[language=Idris]
    data Vect : Nat -> Type -> Type where
      Nil : Vect 0 a
      (::) : (x : a) -> Vect k a -> Vect (S k) a
  \end{lstlisting}

  \begin{itemize}
  \pause
  \item The full \texttt{Vect} type constructed from natural number value for length, and a type for the elements.
  \pause
  \item Two constructors define the type recursively (called an inductive type -- we'll see why later).
    \begin{itemize}
    \item One for the empty vector.
    \item Single value concatenated to another vector to make a vector with 1 more element. \textt{S} is successor of natural numbers, +1.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Types and automation}

  Idris can help us generate programs based on the types. (All the steps you will see are done automatically by Idris).

  \pause \\~\\

  We can ask idris to start our function definition based on the type:

  \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append xs ys = ?append_rhs
  \end{lstlisting}

  \pause
  \texttt{?append\_rhs} is a hole. It's a stand in for a value we need
  to provide. Idris can tell us the type of a hole, and potentially fill
  it in for us. It also tells us types of what's in scope for the hole. This looks like this:

  \pause \\~\\

  \begin{lstlisting}[language=Idris]
- + Main.append_rhs [P]
 `--             elem : Type
                    m : Nat
                   ys : Vect m elem
                    n : Nat
                   xs : Vect n elem
     ----------------------------------------
      Main.append_rhs : Vect (plus n m) elem
  \end{lstlisting}

  
\end{frame}

\begin{frame}[fragile]
  \frametitle{Types and automation}
  \begin{onlyenv}<1>
    Hey Idris...
    \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append xs ys = ?append_rhs      
    \end{lstlisting}
  \end{onlyenv}
  \begin{onlyenv}<2>
    Do a case split on the first argument.
    \begin{lstlisting}[language=Idris]
    append : Vect n elem -> Vect m elem -> Vect (n + m) elem
    append [] ys = ?append_rhs_1
    append (x :: xs) ys = ?append_rhs_2
    \end{lstlisting}
  \end{onlyenv}
\end{frame}

\end{document}
