\documentclass{beamer}

\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

% Colours for beamer.
\setbeamercolor{frametitle}{fg=orange}
\setbeamertemplate{itemize item}{\color{orange}$\blacksquare$}
\setbeamertemplate{itemize subitem}{\color{orange}$\blacktriangleright$}

% Colours for syntax highlighting
\definecolor{syntax_red}{rgb}{0.7, 0.0, 0.0} % For strings
\definecolor{syntax_green}{rgb}{0.15, 0.5, 0.25} % For comments
\definecolor{syntax_orange}{rgb}{0.7, 0.4, 0.2} % For keywords


% Haskell settings for lstlisting
\lstset{language=Haskell,
basicstyle=\ttfamily,
keywordstyle=\color{syntax_orange}\bfseries,
stringstyle=\color{syntax_red},
commentstyle=\color{syntax_green},
numbers=none,
numberstyle=\color{black},
stepnumber=1,
numbersep=10pt,
tabsize=4,
showspaces=false,
showstringspaces=false}

\author{
  Beck, Calvin\\
  \href{mailto:hobbes@ualberta.ca}{hobbes@ualberta.ca}
}

\begin{document}

\begin{frame}
  \frametitle{A Journey Through Types}
  \maketitle
\end{frame}

\section{Introduction}

\begin{frame}
  \frametitle{What is this Talk about?}

  Types! This presentation hopes to address the following:

  \begin{itemize}
  \item How types make things easier to write.
  \item How types can help you write correct software.
  \end{itemize}

  \pause

  Somewhat of a whirlwind introduction. Let me know if you're lost,
  because this talk is all over the place!
\end{frame}

\section{What are types, and how do they help us?}

\begin{frame}[fragile]
  \frametitle{What are we trying to solve?}

  You think that this is normal...

  \pause

  \begin{lstlisting}[frame=single, language=Python, breaklines=true]
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: 'NoneType' object is not subscriptable
  \end{lstlisting}

  \pause

  \huge{... It's not!}
\end{frame}

\begin{frame}
  \frametitle{What is a type?}

  A type describes what a value ``is''.

  \pause

  You have probably heard of this as ``how the bits are stored in memory.''

  \pause

  It's a bit more than that!

  \pause

  \begin{itemize}
  \item Tell us how to use values.
    \pause

    \begin{itemize}
    \item Tells us what operations are defined on the types.
    \item Can you add things of this type?
    \item Can a function take a value of this type as an argument?
    \item What kind of stuff does this function return?
    \end{itemize}

  \pause

  \item Documentation

  \pause

  \item Rejection of general nonsense: \(357^\text{circles}\)

  \pause

  \begin{itemize}
  \item \huge{NO MORE NULL REFERENCE EXCEPTIONS!}
  \end{itemize}
  \end{itemize}
\end{frame}

\section{The types you may have seen}

\begin{frame}[fragile]
  \frametitle{The types you may have seen: Python}
  \begin{lstlisting}[frame=single, language=Python, breaklines=true, basicstyle=\ttfamily\tiny]
     def my_sort(xs):
         if xs == []:
             return xs
         else:
             first_elem = xs[0]
             rest = xs[1:]

             smaller = my_sort([x for x in rest if x <= first_elem])
             larger = my_sort([x for x in rest if x > first_elem])

             return smaller + [first_elem] + larger


     def my_factorial(n):
         if n == 0:
             return 1
         else:
             return n * my_factorial(n-1)
  \end{lstlisting}

  \pause
  \begin{itemize}
  \item No types to help document functions.

  \pause
  \item No types to catch errors at compile time.
    \begin{itemize}
    \pause
    \item Tests can help...
    \pause
    \item But it's nice to not have to worry about certain errors at all.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The types you may have seen: Python}

  \begin{itemize}
  \item What if we could force functions to be compartmentalized?
    \begin{itemize}
    \item No sneaky IO
    \item No hidden global states
    \end{itemize}
    
  \pause
  \item Wouldn't it be nice to have a description of what a function can and can't do in a concise format?

  \pause
  \item Could the compiler tell us when our function deviates from these descriptions?
    \begin{itemize}
    \item Why wait until runtime to find your mistakes?
    \end{itemize}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The types you may have seen: Java}

  \begin{lstlisting}[frame=single, language=Java, breaklines=true, basicstyle=\ttfamily\tiny]
     Integer factorial(Integer n) {
         if (n == 0) {
             return 1;
         }
         else {
             return n * factorial(n - 1);
         }
     }

     ArrayList<Integer> my_sort(ArrayList<Integer> xs) {
         if (xs.size() == 0) {
             return new ArrayList<Integer>();
         }
         else {
             // ...
             // Calvin is too lazy to write Java
             // ...
         }
     }
   \end{lstlisting}

   \begin{itemize}
   \pause
   \item Can see what functions accept and return!
   \pause
   \item Null references... :c
   \pause
   \item Very verbose. Lots of additional syntactic cruft.
   \end{itemize}

   \pause

   Types aren't bad... \pause Java is bad.
\end{frame}

\begin{frame}
  \frametitle{Greener pastures and better ideas}

  What do we want in our types?

  \begin{itemize}
    \pause
  \item Catch errors at compile time!
    \begin{itemize}
    \item If something is ``wrong'', then why wait for runtime to tell us?
    \end{itemize}
    \pause
  \item Ease reading and writing of programs.
    \begin{itemize}
    \item Act as a kind of documentation.
    \item Guide us when writing programs.
    \item Stop us from making mistakes.
    \end{itemize}
    \pause
  \item Not too much verbosity.
    \begin{itemize}
    \item Nice, clean syntax!
    \end{itemize}
  \end{itemize}   
\end{frame}

\section{Haskell}

\begin{frame}[fragile]
  \frametitle{Introducing Haskell!}
  \begin{lstlisting}[frame=single, language=Java, breaklines=true, basicstyle=\ttfamily\tiny]
     def my_sort(xs):
         if xs == []:
             return xs
         else:
             first_elem = xs[0]
             rest = xs[1:]

             smaller = my_sort([x for x in rest if x <= first_elem])
             larger = my_sort([x for x in rest if x > first_elem])

             return smaller + [first_elem] + larger


     def my_factorial(n):
         if n == 0:
             return 1
         else:
             return n * my_factorial(n-1)
  \end{lstlisting}

  \pause

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     mySort :: Ord a => [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]


     factorial :: Integer -> Integer
     factorial 0 = 1
     factorial n = n * factorial (n - 1)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Introducing Haskell!}
    \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     mySort :: Ord a => [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]


     factorial :: Integer -> Integer
     factorial 0 = 1
     factorial n = n * factorial (n - 1)
   \end{lstlisting}

   \begin{itemize}
   \item Type inference: compiler can figure out the types of things.
   \item Nice, relatively specific types.
     \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
       -- Causes a type error, because it doesn't make sense.
       mySort [factorial, (*2)]
     \end{lstlisting}

     Something similar in Python would only be caught at runtime
   \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{We need \texttt{Ord}!}
  You might think you could do this:

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     -- Instead of: Ord a => [a] -> [a]
     mySort :: [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]
   \end{lstlisting}

   \pause

   ... But this actually causes a type error!

   \pause

   \begin{itemize}
   \item $a$ could be \emph{any type}
   \item This type could be unorderable
     \begin{itemize}
     \item Like a function, or a picture
     \end{itemize}
   \item Need the constraint so we know we can perform comparisons!
   \end{itemize}

   \pause

   Haskell makes sure we can only perform operations that are defined on values of a given type, but allows us to be general about it. This function works with any orderable element still, and not just a fixed type.
   
\end{frame}

\begin{frame}
  \frametitle{More care in a type}

  Haskell is somewhat careful about what values inhabit a type.

  \pause
  \begin{itemize}
  \item No ``null'' values which inhabit every type.
  \pause
  \item This keeps it so that, for the most part, elements of a type act the same way.
  \pause
  \item Operations on elements of a type work on all values, so no runtime exceptions are raised!
  \end{itemize}

  \pause

  This helps to keep everything sane!
\end{frame}

\begin{frame}[fragile]
  \frametitle{Maybe maybe!}

  Sometimes you need something \emph{like} a null. Maybe a function can't always compute an answer! \\~\\

  \pause
  Enter maybe types: \\~\\

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
    data Maybe a = Just a | Nothing
  \end{lstlisting}

  \pause

  \begin{itemize}
  \item Not just null!
  \pause
  \item Type checker can tell us when we need to handle null.
  \pause
  \item Compile time errors if we don't handle null!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Maybe examples}

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     -- Find out where a value is in a function.
     getIndex :: Eq a => a -> [a] -> Maybe Integer
     getIndex = getIndexAcc 0

     -- Helper function that remembers our position in the list.
     getIndexAcc :: Eq a => Integer -> a -> [a] -> Maybe Integer
     getIndexAcc pos value [] = Nothing
     getIndexAcc pos value (x::xs) = if x == value
                                        then Just pos
                                        else getIndexAcc (pos+1) xs

     -- A dictionary of all the important words.
     dictionary :: [String]
     dictionary = ["cats", "sandwiches", "hot chocolate"]

     main :: IO ()
     main = do entry <- getLine
               case getIndex entry dictionary of
                    (Just pos) => putStrLn "Your entry is at position " ++ show pos ++ " in the dictionary."
                    Nothing => putStrLn "Your entry does not appear in the dictionary."
  \end{lstlisting}

  \begin{itemize}
  \pause
  \item You know \texttt{getIndex} can yield a ``null'' value (\textt{Nothing}). Just from type.
  \pause
  \item Could also be a \texttt{Just <Integer>}, such as \texttt{Just 3}.
  \pause
  \item You have to explicitly unwrap these values (see \textt{main}) to get at the possible value!
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Maybe more!}

  Seems tedious? It's not! Good syntax makes this easy!
  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
-- Look up a word in the same position in a different dictionary.
dictionary :: [String]
dictionary = ["cats", "sandwiches", "hot chocolate"]


synonyms :: [String]
synonyms = ["meows", "bread oreos", "sweet nectar"]


moreSynonyms :: [String]
moreSynonyms = ["floofs", "subs", "hot coco"]


getIndex :: Integer -> [a] -> Maybe a
getIndex _ [] = Nothing
getIndex 0 (x:xs) = Just x
getIndex n (_:xs) = getIndex (n-1) xs
  \end{lstlisting}

  More on next slide...

\end{frame}

\begin{frame}[fragile]
  Seems tedious? It's not! Good syntax makes this easy!

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
lookupSynonyms :: String -> Maybe (String, String)
lookupSynonyms word = do index <- getIndex word dictionary

                         -- Lookup my synonyms, if anything fails return Nothing.
                         firstSynonym <- getIndex index synonyms
                         secondSynonym <- getIndex index moreSynonyms

                         -- Success! Return Just the synonyms.
                         Just (firstSynonym, secondSynonym)

-- lookupSynonyms essentially desugars to this.
-- The compiler can help avoid this tedium!
painfulLookupSynonyms :: String -> Maybe (String, String)
painfulLookupSynonyms word = case getIndex word dictionary of
                                  Nothing -> Nothing
                                  (Just index) ->
                                    case getIndex index synonyms of 
                                         Nothing -> Nothing
                                         (Just first) ->
                                           case getIndex index moreSynonyms of
                                                Nothing -> Nothing
                                                (Just second) -> Just (first, second)

main :: IO ()
main = do word <- getLine
          case lookupSynonym word of
            Nothing -> putStrLn ("Hmmm, I don't know a synonym for " ++ word)
            (Just synonym) -> putStrLn ("I think " ++ word ++ "'s are a lot like " ++ synonym ++ "'s!")
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{IO types}

  \begin{lstlisting}[frame=single, language=Haskell, breaklines=true, basicstyle=\ttfamily\tiny]
     -- putStrLn :: IO ()
     -- getLine :: IO String

     main :: IO ()
     main = do putStrLn "What is your name?"
               name <- getLine
               putStrLn ("Hello, " ++ name)
  \end{lstlisting}

  \begin{itemize}
  \pause
  \item \texttt{()} is ``void'' --- no return value.
  \pause
  \item \texttt{IO} means a function performs input / output.
    \begin{itemize}
    \pause
    \item Reads from disk, or stdin
    \pause
    \item Writes to disk, prints to screen
    \pause
    \item etc...
    \end{itemize}
  \item No escaping \texttt{IO}. Taints anything using it, so you know if something does input / output.
  \pause
  \item Can help avoid unexpected behaviour.
  \end{itemize}

\end{frame}

\end{document}
