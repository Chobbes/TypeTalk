* Introduction

Hi all!

My name is Calvin and I'm here to talk to you about a couple of things
-- mostly types, and how they can help you write correct programs! I
have a couple bullet points here, to summarize what I want to talk
about:

1) You should care, and you NEED to care about your software.
   Computers are undeniably integral to *every* aspect of our lives.
   Ever larger portions of our lives are controlled by computers as
   the days go by. Whether it's a voting machine, banking software, or
   a component of a vehicle, there's always a programmer behind it
   somewhere.

   This should terrify you if you have ever programmed before.

   An incorrect program may just be annoying and lose a business a
   customer, or an incorrect program could kill somebody if for
   instance it's the software running a pacemaker.

   We need to be careful!

2) Types are a good way to help you with how scary the first point is!

3) Not only are types great for writing correct programs, but they can
   make it a lot easier to write programs in the first place! They help
   the compiler help you!

This is going to be somewhat of a whirlwind introduction to the world
of types, so if you get lost along the way that's okay. Just let me
know and hopefully I can clarify things along the way, and if I can't
do that in the allotted time, don't fret! Talk to me after the fact!
Sometimes it takes a while to grok mathy stuff!

* What are we trying to solve?

You think that this is a normal, and necessary thing:

# picture of various runtime exceptions.

That's bad. Runtime exceptions don't actually /have/ to exist, and it
can be very bad if our pacemaker segfaults. So maybe we should avoid
these problems in the first place! I'll talk a little about what we
can do to avoid these problems. Later on in the talk we'll dip a
little into how you can guarantee that the logic in your program is
correct too, and not just that it does not explode at runtime. All of
this is going to involve a little help from types.

* What is a type?

  A type describes what a value "is".

  You've probably heard of types in programming languages, and
  probably even used them. Most of the time you see them in the
  context of "it tells the compiler how to store the value in memory",
  and while that's true it's not the entire picture.

  Over the years in computing science and mathematics we've learned
  that types are good for a lot more than just figuring out how to lay
  out bits in memory.

  Types tell us how you can use values -- what operations are defined
  on the type? Can you add things of that type? Can a function take a
  value of a certain type as an argument?

  This can really help us write programs that make sense! And these
  types are excellent documentation which the compiler can ensure is
  accurate! A type checker can be used to reject programs which
  consist of nonsense like $357^{circles}$, and in fact types can
  eliminate entire classes of errors if designed properly. No more
  null reference exceptions!

* The types you may have seen.

  You might have already seen how a few languages use types. Let's discuss some of them quickly!

** Python
   In Python we might have something like this:

   #+BEGIN_SRC python
     def my_sort(xs):
         if xs == []:
             return xs
         else:
             first_elem = xs[0]
             rest = xs[1:]

             smaller = my_sort([x for x in rest if x <= first_elem])
             larger = my_sort([x for x in rest if x > first_elem])

             return smaller + [first_elem] + larger


     def my_factorial(n):
         if n == 0:
             return 1
         else:
             return n * my_factorial(n-1)
   #+END_SRC

   Python likes to pretend that types aren't a thing, so Python
   doesn't tell us anything about what a function like this can do. We
   can pass this function whatever we want as an argument, and it may
   or may not fail -- we don't know until we run the program or read
   it very carefully.

   Naming and documentation can help, but in practice, since it can't
   be done automatically, enforcing good naming and documentation is
   really damn hard.

   In a large code base it's difficult to even know what you should
   pass to a function. Should it take a list, or a set? Should it take
   an int, or a float? This factorial function only works with ints (a
   non-integer number will never trigger the base case), but you might
   not realize you're calling it with floats until it's too late! Can
   you simply pass the result of another function to this one, or
   might that function return None, which this factorial function
   can't handle?  You can't know for sure until you read what that
   other function does, and what every function that function calls
   does. That's a lot of work!  You can run your program, perhaps with
   a suite of tests, but that can easily miss a special case.

   Another concern is that this function could do a bunch of secret
   stuff. It could throw away the argument, and read in an integer
   from some file -- maybe it will crash if that file doesn't exist!
   It could change the value of some global variable, causing it to
   return different values depending on the last time it was called --
   and this might cause other functions to behave differently as well!
   This can make your program a complicated web of states, which is
   really difficult to wrap your head around because you need to
   understand it in its entirety -- calling any function could have a
   drastic effect on the behavior of your program. We've all been
   here, and it's awful! Often better to rewrite the program than it
   is to debug it! It would be nice to keep things separated into nice
   modular compartments that don't affect each other. That's what
   functions are supposed to do, but very often they rely upon outside
   state so they're not actually compartmentalized.

   What if we could force functions to be compartmentalized so we
   can't make these mistakes!? What if we could express what a
   function can and can't do in a concise format, and then have the
   compiler or interpreter tell us when something could go wrong! Why
   should we accept runtime exceptions when we can catch these
   problems early on!?

   Just a hint, but this is very possible! And we're going to do it
   will types!

** Java

   In languages like Java you have to specify the types of things:

   #+BEGIN_SRC java
     Integer factorial(Integer n) {
         if (n == 0) {
             return 1;
         }
         else {
             return n * factorial(n - 1);
         }
     }

     ArrayList<Integer> my_sort(ArrayList<Integer> xs) {
         if (xs.size() == 0) {
             return new ArrayList<Integer>();
         }
         else {
             ...
         }
     }
   #+END_SRC

   This little bit of added verbosity actually helps us a lot! We
   don't run into issues with non-termination when we accidentally
   pass in a floating point value like 3.1, and we get to know a
   little bit about what this function can do -- we can see from the
   types that it takes an integer value, and returns an integer value.

   Some languages that do this kind of thing will perform implicit
   type conversions. If we call ~factorial(3.1)~ these languages might
   convert the floating point number 3.1 to the integer value 3
   without telling us about it. This might seem convenient, but
   sometimes this can lead to really nasty and hard to track down bugs
   when you think you're doing one thing, but the language is hiding
   these sneaky conversions behind the scenes. I'm of the opinion that
   it's better to explicitly convert the values -- you don't actually
   want to do conversions that often, and when you do it's better to
   know when it's happening, otherwise you might end up with
   unexpected behavior.

   Even this Java example has problems. For instance Java is a
   language with null references. A variable of any type in Java (save
   for some primitive types) can have the value `null` assigned to
   it. You've probably seen `null` in languages before, even Python
   sort of has this with `None`. The problem with `null` inhabiting
   every type is that it behaves very poorly with almost every
   operation. Comparing `null` to 0 could lead to a runtime
   exception. Subtracting 1 from `null` would lead to a runtime
   exception. We don't want runtime exceptions, since we might not
   catch them until our application is running in production! It would
   be great if the compiler could tell us when we're doing something
   that doesn't make sense like comparing a null value to an
   integer. Sometimes it makes sense to have `None` values, since a
   computation could have no solution, or fail for some reason, but we
   need the compiler to ensure that we check for these cases. We are
   notoriously bad at checking for null references, and it's
   particularly difficult and verbose when every variable can be null.

   Which leads us to the issue that a lot of people don't like
   declaring types for all of their variables, thinking that this is a
   tedious task when the compiler can clearly see that 3 is an
   integer. We'll see shortly that this extra syntax can be avoided
   most of the time with "type inference", and that when we do choose
   to write types it can actually make writing our programs easier and
   quicker. There's really no excuse not to have types!

   Languages like Java are what you might think of when you think of
   types, and maybe that makes you think types are bad. I assure you
   that it's Java that's wrong, and not the types!

* A better idea

  Alright, so there are a few things that can make types better for
  us. First of all we should identify some important qualities that we
  want.

  - Catch errors at compile time. If something is "wrong", why wait for the program to run to tell us?
  - Ease reading and writing programs.
  - Allow us to specify properties, and guarantees within our programs. E.g., this function does not alter global state, or read from a file.

** Haskell

   So, our trip through the land of types brings us to
   Haskell. Haskell is a programming language which treats types
   well. The syntax may be a little different than what you're used
   to, but it's surprisingly clean, concise, and precise. Haskell is
   quite a mathematical language.

   Recall the Python programs from earlier:

   #+BEGIN_SRC python
     def my_sort(xs):
         if xs == []:
             return xs
         else:
             first_elem = xs[0]
             rest = xs[1:]

             smaller = my_sort([x for x in rest if x <= first_elem])
             larger = my_sort([x for x in rest if x > first_elem])

             return smaller + [first_elem] + larger


     def my_factorial(n):
         if n == 0:
             return 1
         else:
             return n * my_factorial(n-1)
   #+END_SRC

   These might look like this in Haskell

   #+BEGIN_SRC haskell
     mySort :: Ord a => [a] -> [a]
     mySort [] = []
     mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
       where smaller = mySort [x | x <- rest, x <= first_elem]
             larger = mySort [x | x <- rest, x > first_elem]


     factorial :: Integer -> Integer
     factorial 0 = 1
     factorial n = n * factorial (n - 1)
   #+END_SRC

   This actually looks pretty nice! In each of these functions it does
   what's called pattern matching to break down the different
   cases. You hardly have to write any type signatures at all, but
   it's useful to write the top level signatures that you see here as
   it helps guide you when writing the function -- it acts as a little
   specification and the compiler can tell you if you deviate.

   In the sort function you'll see what's called a typeclass
   constraint, "Ord", which stands for "ordered", and a type variable
   "a". This means that "a" can be any type as long as it implements
   the functions in "Ord", which contains things like "less than",
   "equal to", and "greater than" comparisons.

   This is great, because now we know exactly what we can do with the
   elements of the list passed into the sort function! We can compare
   them, and since they have an ordering we can sort them!

   Now if you try to sort a list of unorderable things, like
   functions, the compiler will complain.

   #+BEGIN_SRC haskell
     mySort [factorial, (*2), lambda x] -- Causes a type error, because it doesn't make sense.
   #+END_SRC

   Whereas in python it will just cause a runtime exception.

   #+BEGIN_SRC python
     # This causes an error when the program is running...
     # We might not catch something like this until it hits production!
     sorted([lambda x: x * 2, lambda x: x ** 2])
   #+END_SRC
   
   Haskell is also a bit more strict about what its types mean. For
   instance we know that these functions can't return "None" or
   "null". In the case of the factorial function it MUST return an
   integer value of some kind, and in Haskell there is no "None" or
   "null" value under the Integer type.

   These "Nothing" values are encoded in so-called "Maybe" types,
   i.e., types which may contain just a value of a given type, or may
   yield Nothing.

   #+BEGIN_SRC haskell
     -- Find out where a value is in a function.
     getIndex :: Eq a => a -> [a] -> Maybe Integer
     getIndex = getIndexAcc 0

     -- Helper function that remembers our position in the list.
     getIndexAcc :: Eq a => Integer -> a -> [a] -> Maybe Integer
     getIndexAcc pos value [] = Nothing
     getIndexAcc pos value (x::xs) = if x == value
                                        then Just pos
                                        else getIndexAcc (pos+1) xs
            

     -- A dictionary of all the important words.
     dictionary :: [String]
     dictionary = ["cats", "sandwiches", "hot chocolate"]


     main :: IO ()
     main = do entry <- getLine
               case getIndex entry dictionary of
                    (Just pos) => putStrLn "Your entry is at position " ++ show pos ++ " in the dictionary."
                    Nothing => putStrLn "Your entry does not appear in the dictionary."
   #+END_SRC

   In this case you know that "getIndex" can return something like a
   "null" value called "Nothing", but it could also return "Just" an
   Integer. You have to explicitly unwrap these values, like in the
   case statement, to get at the possible value. This might seem
   tedious, but if you're a fancy Haskell person you might use "do"
   notation, which does this automatically.

   #+BEGIN_SRC haskell
     -- Look up a word in the same position in a different dictionary.
     dictionary :: [String]
     dictionary = ["cats", "sandwiches", "hot chocolate"]


     synonyms :: [String]
     synonyms = ["meows", "bread oreos", "sweet nectar"]


     getIndex :: Integer -> [a] -> Maybe a
     getIndex _ [] = Nothing
     getIndex 0 (x:xs) = Just x
     getIndex n (_:xs) = getIndex (n-1) xs


     lookupSynonym :: String -> Maybe String
     lookupSynonym word = do index <- getIndex word dictionary
                             getIndex index synonyms

     -- Lookup synonyms essentially desugars to this.
     -- The compiler can help avoid this tedium!
     painfulLookupSynonyms :: String -> Maybe String
     painfulLookupSynonyms word = case getIndex word dictionary of
                                       Nothing -> Nothing
                                       (Just index) -> case getIndex index synonyms of 
                                                            Nothing -> Nothing
                                                            (Just synonym) -> (Just synonym)

     main :: IO ()
     main = do word <- getLine
               case lookupSynonym word of
                 Nothing -> putStrLn ("Hmmm, I don't know a synonym for " ++ word)
                 (Just synonym) -> putStrLn ("I think " ++ word ++ "'s are a lot like " ++ synonym ++ "'s!")
   #+END_SRC

   Types never really add any extra tedium, and they can often relieve
   it because the compiler can automatically do stuff for you.
   
   These examples also shows how input and output are encoded in the
   types. For example:

   #+BEGIN_SRC haskell
     -- putStr :: IO ()
     -- putStrLn :: IO ()
     -- getLine :: IO String

     main :: IO ()
     main = do putStr "What is your name? "
               name <- getLine
               putStrLn ("Hello, " ++ name)
   #+END_SRC

   The ()'s essentially mean "void" or "no return value," we're just
   printing stuff here. An "IO String", like getLine, is something
   which gets a string value using IO. A function which computes its
   return value based on an IO action will be forced to have an IO
   type as well, so you can't hide IO actions in functions which
   supposedly don't rely upon IO.

   It seems that Haskell satisfies most of our goals.

   1. We can catch errors at compile time. If something is "wrong", why wait for the program to run to tell us?
   2. It eases reading and writing programs. It's nice to know what a function can do based on a small type.
   3. It allow us to specify properties, and guarantees within our programs. E.g., this function does not alter global state, or read from a file.

   For (1) Haskell's type system lets you describe values in a fair
   amount of detail, and mostly doesn't stuff the types with values
   that can cause your program to explode at runtime like null.

   (2) the types help you in much the same way as test driven
   development does. It makes you think about the arguments that your
   functions can take, and what you can compute with those
   arguments. Also when developing it helps point out mistakes, like
   forgetting to unwrap a Maybe value and check each of the cases.

   (3) Functions are "pure", meaning they always produce the same output
       for the same input. Special actions are labeled in the type,
       and for e.g., you can't use an IO value in a non-IO function
       because the IO action would cause the calling function to have
       an IO type as well. IO taints it.

   This is really great, and it's super helpful. There's a saying that
   "if a Haskell function compiles, then it's probably correct"
   because the type system ends up preventing a lot of errors. For
   instance, you never end up trying to index ~None~ like you would in
   Python. However, we can do even better!

* Enter dependent types.
  There are some things that we just can't do even with Haskell's
  types. I can write a function to index a list

  #+BEGIN_SRC haskell
    index :: Integer -> [a] -> Maybe a
    index 0 [] = Nothing
    index 0 (x::xs) = Just x
    index n (x::xs) = index (n-1) xs
  #+END_SRC

  But I can't write one that the compiler can ensure is never called
  with an index outside the range of our list.

  #+BEGIN_SRC haskell
    -- Want the integer argument to always be in range so we don't need
    -- Maybe!
    index :: Integer -> [a] -> a
    index 0 [] = error "Uh... Whoops, walking off the end of the list!"
    index 0 (x :: xs) = x
    index n (x :: xs) = index (n-1) xs
  #+END_SRC

  We need to somehow encode the length of the list into the type so we
  can only call index when the position provided is in range.

  It's also not possible to encode other properties which depend upon
  values in the types. For instance I can't say that a function
  returns a list of values which are sorted in ascending order, I can
  only say that a sort function also returns a list with values of the
  same type...

  #+BEGIN_SRC haskell
    mySort :: Ord a => [a] -> [a]
    mySort [] = []
    mySort (first_elem::rest) = smaller ++ [first_elem] ++ larger
      where smaller = mySort [x | x <- rest, x <= first_elem]
            larger = mySort [x | x <- rest, x > first_elem]
  #+END_SRC

  It's nice that we can specify that this function only works on lists
  which have orderable elements, but it would be even better if we
  could also say things like...

  1. The output list must have the same length as the input list.
  2. The list in the output must contain the same elements as the input list.
  3. The output list must be sorted in ascending order.

  If we could encode these properties in the types, then if the
  program type checks it would prove that our sort function does the
  right thing.

  In fact, that's an interesting idea, isn't it? Why don't we make it
  so we can encode essentially any set of properties in our types, any
  proposition we can think of, and then make it so our program only
  type checks if it satisfies these properties. That would be a very
  powerful tool for ensuring the correctness of our programs! Maybe we
  can even use such a type checker to help us with our proofy math homework?

* Logic Primer

  In order to get into this we need to do a quick primer on logic and
  logical proofs. In logic you have things known as propositions. A
  proposition is just a statement, such as "the sky is blue", or "2 +
  2 is 4". These propositions happen to be true, but we can also
  have propositions which are false, such as "2 + 2 is 27". A
  proposition is just something that you can propose. I might propose
  to you the notion that "2 + 2 is 27", but using logical proofs we
  can determine that this proposition is in fact not a true statement.

  So! These propositions are often represented by variables, for
  instance:

  #+BEGIN_SRC haskell
    P
  #+END_SRC

  ~P~ is a proposition. It could be anything, really...

  #+BEGIN_SRC haskell
    P = "ducks are fantastic"
  #+END_SRC

  And I might have another proposition:

  #+BEGIN_SRC haskell
    Q = "ducks are truly the worst"
  #+END_SRC

  Right now I'm using plain English to convey these propositions to
  you, but often they'll be more mathematical statements, such as:

  $$\forall n, \exists n \in \mathrm{N} \text{ such that } n > m$$

* Curry-Howard Isomorphism

  As it turns out when you start to think of your types as
  propositions some interesting things start to pop up...

  For instance if we look at something like implication in logic...

  #+BEGIN_SRC haskell
    P -> Q
  #+END_SRC

  This means that if I have a proof of the proposition P, then I can
  produce a proof of the proposition Q.

  That's very similar to a function type in something like Haskell. If
  I'm given a value of type P, then I can produce a value of type
  Q. So function application seems to be pretty much identical to
  modus ponens.

  Similarly in logic I might have

  #+BEGIN_SRC haskell
    P /\ Q
  #+END_SRC

  Which means that I have a proof of P and a proof of Q.

  If you squint that's kind of similar to:

  #+BEGIN_SRC haskell
    (P, Q)
  #+END_SRC

  Which means that I have a value of P, and a value of Q. Conjunction
  elimination is then just the projection of either the first or
  second value in the tuple:

  #+BEGIN_SRC haskell
    -- P /\ Q -> P
    fst :: (p, q) -> p
    fst (a, b) = a

    -- P /\ Q -> Q
    snd :: (p, q) -> q
    snd (a, b) = b
  #+END_SRC
